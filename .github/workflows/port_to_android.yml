name: Switch to C++ Native Rendering

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  native-render:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # 1. Atualiza CMakeLists.txt para incluir a lib 'android' (necessária para ANativeWindow)
      - name: Update CMakeLists.txt
        run: |
          cat <<EOF > app/src/main/cpp/CMakeLists.txt
          cmake_minimum_required(VERSION 3.10.2)
          project("comsquare")

          set(ROOT_DIR \${CMAKE_CURRENT_SOURCE_DIR})
          include_directories("\${ROOT_DIR}/sources")

          file(GLOB_RECURSE CORE_SOURCES
              "\${ROOT_DIR}/sources/*.cpp"
              "\${ROOT_DIR}/sources/*.c"
              "\${ROOT_DIR}/native-lib.cpp"
          )

          # Filtros
          list(FILTER CORE_SOURCES EXCLUDE REGEX ".*Qt.*")
          list(FILTER CORE_SOURCES EXCLUDE REGEX ".*SF.*")
          list(FILTER CORE_SOURCES EXCLUDE REGEX ".*Debugger.*")
          list(FILTER CORE_SOURCES EXCLUDE REGEX ".*tests.*")
          list(FILTER CORE_SOURCES EXCLUDE REGEX ".*/main\\.cpp$")

          add_library(comsquare SHARED \${CORE_SOURCES})

          # Adiciona a biblioteca 'android' para manipulação nativa de janelas
          find_library(android-lib android)
          find_library(log-lib log)

          target_link_libraries(comsquare \${log-lib} \${android-lib})
          EOF

      # 2. Implementa renderização C++ pura em native-lib.cpp
      - name: Overwrite native-lib.cpp
        run: |
          cat <<EOF > app/src/main/cpp/native-lib.cpp
          #include <jni.h>
          #include <string>
          #include <memory>
          #include <android/log.h>
          #include <android/native_window.h>
          #include <android/native_window_jni.h>

          #include "SNES.hpp"
          #include "AndroidRenderer.hpp"

          // Globais
          std::unique_ptr<ComSquare::Renderer::AndroidRenderer> g_renderer;
          std::unique_ptr<ComSquare::SNES> g_snes;
          ANativeWindow* g_window = nullptr;

          // Resolução nativa do SNES (geralmente 256x224, mas o buffer interno é 1024)
          // Vamos configurar o buffer da janela para 256x224 para o Android fazer o upscale via Hardware
          const int SNES_WIDTH = 256;
          const int SNES_HEIGHT = 224;

          extern "C" JNIEXPORT void JNICALL
          Java_com_comsquare_emulator_MainActivity_initNative(JNIEnv* env, jobject) {
              g_renderer = std::make_unique<ComSquare::Renderer::AndroidRenderer>();
              g_snes = std::make_unique<ComSquare::SNES>(*g_renderer);
              __android_log_print(ANDROID_LOG_INFO, "ComSquare", "Core Initialized");
          }

          extern "C" JNIEXPORT void JNICALL
          Java_com_comsquare_emulator_MainActivity_loadRomNative(JNIEnv* env, jobject, jstring path) {
              const char *nativePath = env->GetStringUTFChars(path, 0);
              if (g_snes) {
                  try {
                      g_snes->loadRom(std::string(nativePath));
                  } catch (...) {}
              }
              env->ReleaseStringUTFChars(path, nativePath);
          }

          extern "C" JNIEXPORT void JNICALL
          Java_com_comsquare_emulator_MainActivity_setSurface(JNIEnv* env, jobject, jobject surface) {
              // Se já existe uma janela, libera
              if (g_window) {
                  ANativeWindow_release(g_window);
                  g_window = nullptr;
              }

              // Se uma nova superfície foi passada, configura
              if (surface) {
                  g_window = ANativeWindow_fromSurface(env, surface);
                  // Define o tamanho do buffer interno. O Android estica isso para o tamanho da tela.
                  // Isso é muito mais rápido do que fazer scaling via software.
                  ANativeWindow_setBuffersGeometry(g_window, 1024, 1024, WINDOW_FORMAT_RGBA_8888);
              }
          }

          extern "C" JNIEXPORT void JNICALL
          Java_com_comsquare_emulator_MainActivity_runFrame(JNIEnv* env, jobject) {
              if (!g_snes || !g_renderer) return;

              // 1. Atualiza Lógica do Emulador
              try { 
                  g_snes->update(); 
              } catch(...) { return; }

              // 2. Renderização Direta (Sem JNI Bitmap Copy)
              if (g_window) {
                  ANativeWindow_Buffer buffer;
                  if (ANativeWindow_lock(g_window, &buffer, nullptr) == 0) {
                      
                      const uint32_t* src = g_renderer->getPixels();
                      uint32_t* dst = (uint32_t*)buffer.bits;
                      
                      // Copia linha a linha considerando o stride (largura real da memória)
                      // O PPU original desenha em um buffer de 1024x1024
                      // Como definimos a geometria da janela para 1024x1024, podemos copiar direto.
                      
                      // Otimização: Copia apenas a área relevante se possível, 
                      // mas aqui vamos copiar o buffer todo para garantir que funcione primeiro.
                      // src size = 1024 * 1024
                      
                      // Cuidado: buffer.stride pode ser maior que width
                      int lineSize = 1024 * 4; // 1024 pixels * 4 bytes
                      for (int i = 0; i < 1024; ++i) {
                          memcpy(dst + (i * buffer.stride), src + (i * 1024), lineSize);
                      }

                      ANativeWindow_unlockAndPost(g_window);
                  }
              }
          }
          EOF

      # 3. Limpa MainActivity (Remove Canvas, Remove Bitmap, Adiciona setSurface)
      - name: Overwrite MainActivity.kt
        run: |
          cat <<EOF > app/src/main/java/com/comsquare/emulator/MainActivity.kt
          package com.comsquare.emulator

          import android.graphics.Color
          import android.net.Uri
          import android.os.Bundle
          import android.view.Surface
          import android.view.SurfaceHolder
          import android.view.SurfaceView
          import android.view.View
          import android.widget.Button
          import android.widget.TextView
          import android.widget.Toast
          import androidx.activity.result.contract.ActivityResultContracts
          import androidx.appcompat.app.AppCompatActivity
          import kotlinx.coroutines.*
          import java.io.File
          import java.io.FileOutputStream

          class MainActivity : AppCompatActivity() {

              private lateinit var surfaceView: SurfaceView
              private lateinit var tvStatus: TextView
              private lateinit var btnLoadRom: Button
              
              private var emulatorJob: Job? = null
              @Volatile private var isRunning = false
              
              private val filePickerLauncher = registerForActivityResult(ActivityResultContracts.OpenDocument()) { uri: Uri? ->
                  uri?.let { loadGameFromUri(it) }
              }

              override fun onCreate(savedInstanceState: Bundle?) {
                  super.onCreate(savedInstanceState)
                  setContentView(R.layout.activity_main)

                  surfaceView = findViewById(R.id.emulatorSurface)
                  tvStatus = findViewById(R.id.tvStatus)
                  btnLoadRom = findViewById(R.id.btnLoadRom)

                  initNative()

                  btnLoadRom.setOnClickListener {
                      filePickerLauncher.launch(arrayOf("*/*"))
                  }

                  surfaceView.holder.addCallback(object : SurfaceHolder.Callback {
                      override fun surfaceCreated(holder: SurfaceHolder) {
                          // Passa a superfície nativa para o C++
                          setSurface(holder.surface)
                          if (isRunning) startEmulatorLoop()
                      }

                      override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int, height: Int) {
                          // C++ gerencia a escala automaticamente via ANativeWindow_setBuffersGeometry
                      }

                      override fun surfaceDestroyed(holder: SurfaceHolder) {
                          // Avisa o C++ que a superfície morreu
                          setSurface(null)
                      }
                  })
              }

              private fun loadGameFromUri(uri: Uri) {
                  try {
                      val inputStream = contentResolver.openInputStream(uri)
                      val tempFile = File(cacheDir, "game.sfc")
                      val outputStream = FileOutputStream(tempFile)
                      inputStream?.copyTo(outputStream)
                      inputStream?.close()
                      outputStream.close()

                      loadRomNative(tempFile.absolutePath)
                      
                      tvStatus.visibility = View.GONE
                      btnLoadRom.visibility = View.GONE
                      isRunning = true
                      
                      // Inicia o loop se a superfície já estiver pronta (ou espera o callback)
                      if (surfaceView.holder.surface.isValid) {
                          setSurface(surfaceView.holder.surface)
                          startEmulatorLoop()
                      }
                      
                  } catch (e: Exception) {
                      tvStatus.text = "Error: \${e.message}"
                  }
              }

              private fun startEmulatorLoop() {
                  emulatorJob?.cancel()
                  emulatorJob = CoroutineScope(Dispatchers.Default).launch {
                      while (isActive && isRunning) {
                          val start = System.currentTimeMillis()
                          
                          // Toda a mágica acontece no C++ agora (Update + Render)
                          runFrame()
                          
                          val diff = System.currentTimeMillis() - start
                          if (diff < 16) delay(16 - diff)
                      }
                  }
              }

              external fun initNative()
              external fun loadRomNative(path: String)
              external fun setSurface(surface: Surface?) // Novo método: Passa o Surface direto
              external fun runFrame() // Antigo updateFrame, agora faz tudo

              companion object {
                  init { System.loadLibrary("comsquare") }
              }
          }
          EOF

      - name: Commit and Push changes
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add app/src/main/cpp/CMakeLists.txt
          git add app/src/main/cpp/native-lib.cpp
          git add app/src/main/java/com/comsquare/emulator/MainActivity.kt
          git commit -m "Refactor: Move rendering logic to C++ using ANativeWindow"
          git push
